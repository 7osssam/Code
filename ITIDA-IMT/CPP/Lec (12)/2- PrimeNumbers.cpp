#include <iostream>
#include <vector>
#include <thread>
#include <cmath>
#include <mutex>
#include <chrono>

bool isPrime(int num)
{
	if (num == 2)
		return true;

	if ((num <= 1) || (num % 2 == 0))
		return false;

	for (int i = 3; i <= std::sqrt(num); i += 2)
	{
		if (num % i == 0)
			return false;
	}
	return true;
}
void DisplayVector(const std::vector<int>& v)
{
	for (auto i: v)
	{
		std::cout << i << " ";
	}
}

void generatePrimes(int start, int end, std::vector<int>& primes)
{
	// no need for lock_guard since we are not using any shared resources as every thread has its own vector
	//std::mutex lock;
	//std::lock_guard<std::mutex> lk(lock);

	for (int num = start; num <= end; ++num)
	{
		if (isPrime(num))
		{
			primes.push_back(num);
		}
	}
	std::cout << "Thread ID: " << std::this_thread::get_id() << std::endl;
	DisplayVector(primes);
	std::cout << std::endl;
}

// Timer class
class Timer
{
public:
	Timer()
	{
		start = std::chrono::high_resolution_clock::now();
	}

	auto Stop()
	{
		stop = std::chrono::high_resolution_clock::now();
		auto duration = std::chrono::duration_cast<std::chrono::microseconds>(stop - start);
		return duration.count();
	}

private:
	std::chrono::time_point<std::chrono::high_resolution_clock> start, stop;
};

int main()
{
	int limit, numThreads;
	std::cout << "Enter the limit: ";
	std::cin >> limit;
	std::cout << "Enter the number of threads: ";
	std::cin >> numThreads;

	const int numCores = std::thread::hardware_concurrency();

	// if number of threads is negative or greater than the number of hardware threads, return an error
	if ((numThreads <= 0) || (numThreads > numCores))
	{
		std::cerr << "Error: Invalid number of threads\n";
		return EXIT_FAILURE;
	}

	std::vector<std::thread> VecOfthreads; // vector of threads to store the threads

	// vector of vectors to store the prime numbers generated by each thread
	// each small vector will store the prime numbers generated by a single thread
	std::vector<std::vector<int>> primes(numThreads);

	// Start the timer
	Timer timer;

	// every thread will have start and end range and all of them will execute at the same time
	// but each thread will have its own range to generate prime numbers
	for (int ThreadCounter = 0; ThreadCounter < numThreads; ++ThreadCounter)
	{
		// Calculate the start and end of the range for each thread
		// The range is divided equally among the threads based on the number of threads and the limit
		int start = ThreadCounter * (limit / numThreads) + 1; // start of the range (small vector)
		int end = (ThreadCounter + 1) * (limit / numThreads); // end of the range

		// if it is the last thread, set the end to the limit to avoid missing any numbers
		if (ThreadCounter == numThreads - 1)
		{
			end = limit;
		}

		// Create a thread and pass the start, end, and the reference to the small vector to store the prime numbers
		VecOfthreads.push_back(std::thread(generatePrimes, start, end, std::ref(primes[ThreadCounter])));
	}

	// Wait for all threads to finish
	for (auto& t: VecOfthreads)
	{
		t.join();
	}

	std::cout << "Prime numbers to " << limit << " are: " << std::endl;
	// Print all primes
	for (const auto& primeList: primes)
	{
		DisplayVector(primeList);
	}

	// Stop the timer
	auto duration = timer.Stop();
	std::cout << "\nTime taken: " << duration << " microseconds" << std::endl;

	// will try test it later isa

	return 0;
}